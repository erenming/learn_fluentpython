1. 特殊方法`__missing__`： 所有映射类型在处理找不到的键时都会牵扯到`__missing__`方法
2. 字典中的散列表
    - 通过`hash()`计算散列值
    - Python会保证1/3的表元为空，当快要达到阈值时，原有散列表会被复制到一个更大的空间里面
    - 散列算法
    ![xx](https://github.com/erenming/learn_fluentpython/raw/master/notes/images/WX20190225-224311@2x.png)
3. dict的实现及其导致的结果
    - 键必须是可散列的，需满足
        1. 支持`hash()`, 并通过该`__hash__()`得到的散列值不变
        2. 支持`__eq__()`检测相等性
        3. 若`a == b`为真，则`hash(a) == hash(b)`也为真
    - 内存开销大
    - 键查询快
    - 键的次序*取决于*添加顺序
        1. 当往dict里添加新键而又发生冲突的时候，新键可能会被安排存放到另一个位置。
        2. 因此，对于同样的数据源，插入顺序的不同只会影响到数据出现的顺序。而字典本身是相等的
    - 往字典里添加新键可能会改变已有键的顺序
        1. 添加键, 可能会导致字典的扩容。把字典已有元素复制到新表中时，可能会发生冲突，从而导致键的次序改变
4. set的实现及其导致的结果
    - 集合内元素必须是可散列的
    - 集合很耗内存
    - 很高效地判断元素是否存在于集合
    - 元素次序取决于添加顺序
    - 往集合内添加元素，可能会导致集合已有顺序改变
5. 装饰器
    - 能把被装饰的函数替换成其他函数
    - 装饰器在模块加载时立即执行